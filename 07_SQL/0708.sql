SELECT EMP_ID, EMP_NAME, DEPT_CODE
FROM TEMP
WHERE EMP_ID = 19970101;

SELECT DEPT_CODE, DEPT_NAME
FROM TDEPT
ORDER BY 1;
--NON-EQUIJOIN
SELECT TEMP.EMP_ID, TEMP.EMP_NAME, TEMP.DEPT_CODE,
        TDEPT.DEPT_CODE, TDEPT.DEPT_NAME
FROM TEMP, TDEPT
WHERE EMP_ID = 19970101    
AND TEMP.DEPT_CODE < TDEPT.DEPT_CODE;
--OUTERJOIN
SELECT TEMP.EMP_ID, TDEPT.BOSS_ID
FROM TEMP, TDEPT
WHERE TEMP.EMP_ID = TDEPT.BOSS_ID(+)
ORDER BY 1;
--SELFJOIN
SELECT A.EMP_ID, A.EMP_NAME, B.EMP_ID, B.EMP_NAME
FROM TEMP A, TEMP B
WHERE A.EMP_ID = B.EMP_ID;
--EQUIJOIN
SELECT EMPLOYEES.EMPLOYEE_ID,EMPLOYEES.LAST_NAME, EMPLOYEES.DEPARTMENT_ID,
        DEPARTMENTS.DEPARTMENT_ID, DEPARTMENTS.DEPARTMENT_NAME
FROM EMPLOYEES, DEPARTMENTS
WHERE EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;
--EQUIJOIN 3개이상의 테이블 조인
SELECT E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID,
       D.DEPARTMENT_ID, D.DEPARTMENT_NAME, L.LOCATION_ID
FROM   EMPLOYEES E, DEPARTMENTS D, LOCATIONS L
WHERE  E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND    D.LOCATION_ID = L.LOCATION_ID;
--EQUIJOIN에 AND절 추가
SELECT E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID,
       D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM   EMPLOYEES E, DEPARTMENTS D
WHERE  E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND    LAST_NAME = 'King';
--NON-EQUIJOIN
SELECT E.LAST_NAME, E.SALARY, J.GRADE_LEVEL
FROM EMPLOYEES E, JOB_GRADES J
WHERE E.SALARY BETWEEN J.LOWEST_SAL AND J.HIGHEST_SAL;
--OUTERJOIN
SELECT E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID,
       D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM   EMPLOYEES E, DEPARTMENTS D
WHERE  E.DEPARTMENT_ID = D.DEPARTMENT_ID(+);
--어느 직원이 어떤 부서에 근무하는 지 검색하되 직원이 배정되지 않은 부서도 출력
SELECT E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID,
       D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM   EMPLOYEES E, DEPARTMENTS D
WHERE  E.DEPARTMENT_ID(+) = D.DEPARTMENT_ID;
--SELFJOIN
SELECT E.LAST_NAME,M.LAST_NAME
FROM EMPLOYEES E, EMPLOYEES M
WHERE E.MANAGER_ID = M.MANAGER_ID;
--CROSSJOIN 두 테이블의 값을 무조건 조인
SELECT LAST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES
CROSS JOIN DEPARTMENTS;

SELECT COUNT(*)
FROM EMPLOYEES
CROSS JOIN DEPARTMENTS;
--NATURAL JOIN
SELECT LAST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES
NATURAL JOIN DEPARTMENTS;
--USING
SELECT LAST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES JOIN DEPARTMENTS
USING (DEPARTMENT_ID);
--ON을 사용
SELECT E.LAST_NAME, D.DEPARTMENT_NAME
FROM EMPLOYEES E JOIN DEPARTMENTS D
ON (E.DEPARTMENT_ID = D.DEPARTMENT_ID);

SELECT EMPLOYEE_ID, DEPARTMENT_NAME, CITY
FROM EMPLOYEES E
JOIN DEPARTMENTS D
ON (E.DEPARTMENT_ID = D.DEPARTMENT_ID)
JOIN LOCATIONS I
ON (D.LOCATION_ID = I.LOCATION_ID);

SELECT E.LAST_NAME, E.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E
LEFT OUTER JOIN DEPARTMENTS D
ON (E.DEPARTMENT_ID = D.DEPARTMENT_ID);

SELECT E.LAST_NAME, E.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E
LEFT OUTER JOIN DEPARTMENTS D
ON (E.DEPARTMENT_ID = D.DEPARTMENT_ID);

SELECT E.LAST_NAME, E.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID(+) = D.DEPARTMENT_ID;
--양쪽을 다잡아냄 오라클표현으로는 불가
SELECT E.LAST_NAME, E.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E
FULL OUTER JOIN DEPARTMENTS D
ON (E.DEPARTMENT_ID = D.DEPARTMENT_ID);

--실습 10000건짜리 테스트 데이터 만들기
SELECT * FROM TEMP;
SELECT * FROM USER_TABLES;
SELECT * FROM TEST17;

CREATE TABLE T1_DATA
AS
SELECT ROWNUM NO
FROM TEMP, USER_TABLES, TEST17
WHERE ROWNUM < 10001;

SELECT COUNT(*) FROM T1_DATA; 
--데이터 만들기
CREATE TABLE TCOM(
        WORK_YEAR VARCHAR2(04) NOT NULL,
        EMP_ID NUMBER NOT NULL,
        BONUS_RATE NUMBER,
        COMM NUMBER,
        CONSTRAINT COM_PK PRIMARY KEY (WORK_YEAR,EMP_ID)
);

INSERT INTO TCOM
SELECT '2018', EMP_ID, 1, SALARY*0.01
FROM TEMP
WHERE DEPT_CODE LIKE 'C%';

SELECT * FROM TCOM;

--과제
--1. TEMP와 TDEPT 를 부서코드로 조인하여 사번,성명,부서코드,부서명 가져오기
--단, SALARY가 9천만원 보다 큰 직원에 대해서
SELECT A.EMP_ID, A.EMP_NAME, A.DEPT_CODE, B.DEPT_NAME
FROM TEMP A, TDEPT B
WHERE A.DEPT_CODE = B.DEPT_CODE AND A.SALARY > 90000000;

--2.2019년에 커미션을 받는 직원의 사번,성명,부서코드,부서명, 커미션 가져오기
SELECT A.EMP_ID, A.EMP_NAME, A.DEPT_CODE, B.DEPT_NAME, C.COMM
FROM TEMP A, TDEPT B, TCOM C
WHERE A.DEPT_CODE = B.DEPT_CODE AND A.EMP_ID = C.EMP_ID AND C.WORK_YEAR = 2019;

--3. TEMP에서 박문수보다  급여를 적게받는 직원 검색
SELECT A.EMP_ID, A.EMP_NAME, A.SALARY
FROM TEMP A, TEMP B
WHERE A.SALARY < B.SALARY AND B.EMP_NAME = '박문수';

SELECT EMP_NAME, EMP_ID, SALARY 
FROM TEMP
WHERE EMP_NAME = '박문수';

--4. EMP_LEVEL 에서 급여 산술평균을 구하고 TEMP 사원 중 자기 직급의 
--   산술평균 보다 급여가 작은 직원 가져오기 
SELECT T.EMP_ID, T.EMP_NAME, T.SALARY, T.LEV
FROM EMP_LEVEL L, TEMP T
WHERE  T.LEV = L.LEV AND T.SALARY < (L.FROM_SAL + L.TO_SAL)/2;

SELECT * FROM EMP_LEVEL;
SELECT * FROM TEMP;
--5. TEMP ,TCOM을 EMP_ID로 연결하여 모든 정보를 가져오되,  TEMP에 존재하는 자료 기준 모두 
SELECT *
FROM TEMP T, TCOM C
WHERE T.EMP_ID = C.EMP_ID(+) AND C.WORK_YEAR(+) = 2019;
--6. EMP_ID 마다 자신보다 SALARY가 높은 인원 COUNT
SELECT A.EMP_ID, COUNT(B.EMP_ID)
FROM TEMP A, TEMP B
WHERE A.SALARY < B.SALARY(+)
GROUP BY A.EMP_ID
ORDER BY 2;
--7. TEMP 와 TDEPT CARTESIAN PRODUCT 생성
SELECT COUNT(*)
FROM TEMP A, TDEPT B;
SELECT * FROM TEMP;
SELECT * FROM TDEPT;
--8. TEMP 와 TDEPT NATURAL JOIN
SELECT EMP_NAME, DEPT_NAME
FROM TEMP
NATURAL JOIN TDEPT;
--9. TEMP 와 TDEPT USING절 사용 NATURAL JOIN
SELECT EMP_NAME, DEPT_NAME
FROM TEMP JOIN TDEPT
USING(DEPT_CODE);
--10. NATURAL JOIN ON 을 사용하여 사원,부서,EMP_LEV 정보 조인
SELECT A.EMP_ID, B.DEPT_NAME, A.LEV
FROM TEMP A JOIN TDEPT B
ON A.DEPT_CODE = B.DEPT_CODE;
--11. 사번, 성명, TEMP.부서코드, TDEPT.부서코드 , 부서명을 가져오는 LEFT OUTER JOIN 수행
SELECT A.EMP_ID, A.EMP_NAME, A.DEPT_CODE, B.DEPT_CODE, B.DEPT_NAME
FROM TEMP A
LEFT OUTER JOIN TDEPT B
ON A.DEPT_CODE = B.DEPT_CODE;
--12. 11번을 FROM절에 오는 테이블과 outer JOIN절에 오는 테이블만 바꿔서 수행
SELECT A.EMP_ID, A.EMP_NAME, A.DEPT_CODE, B.DEPT_CODE, B.DEPT_NAME
FROM TEMP A, TDEPT B
WHERE A.DEPT_CODE = B.DEPT_CODE;
--13. 사번, 성명, TEMP.부서코드, TDEPT.부서코드 , 부서명을 가져오는 RIGHT OUTER JOIN 수행
SELECT A.EMP_ID, A.EMP_NAME, A.DEPT_CODE, B.DEPT_CODE, B.DEPT_NAME
FROM TDEPT B
RIGHT OUTER JOIN TEMP A
ON A.DEPT_CODE = B.DEPT_CODE;
--보너스 문제
--1.사번 ,성명, TEMP.부서코드, TDEPT.부서코드, 부서명을 가져오는 FULL OUTER JOIN 수행
SELECT A.EMP_ID, A.EMP_NAME, A.DEPT_CODE, B.DEPT_CODE, B.DEPT_NAME
FROM TEMP A
FULL OUTER JOIN TDEPT B
ON A.DEPT_CODE = B.DEPT_CODE;

--2.1번에서 사번이 2019로 시작하는 직원만 검색
SELECT A.EMP_ID, A.EMP_NAME, A.DEPT_CODE, B.DEPT_CODE, B.DEPT_NAME
FROM TEMP A
FULL OUTER JOIN TDEPT B
ON A.DEPT_CODE = B.DEPT_CODE AND A.EMP_ID BETWEEN 20190000 AND 20199999;
--3.사원테이블의 SALARY를 홀,짝수 달 1:2의 비율로 나누어 지급하는데 커미션 테이블에 커미션이 등록된 사원은
--  해당 커미션을 매월 급여에 더해 지급하고자 합니다. 별도의 테이블을 만들어 직원 수 만큼의 ROW를 생성하고
--  1월부터 12월까지 지급 금액을 컬럼으로 관리할 수 있도록 하세요.(T2_DATA구조 : EMP_ID, SAL01, SAL02,....,SAL12)
--  단, SALARY를 나눈 급여의 소수점 아래는 원 단위로 올림 처리 합니다.
CREATE TABLE T2_DATA
AS
SELECT T.EMP_ID, T.EMP_NAME, 
        CEIL(T.SALARY/18+NVL(C.COMM,0)) SAL01, CEIL(T.SALARY/9+NVL(C.COMM,0)) SAL02,
        CEIL(T.SALARY/18+NVL(C.COMM,0)) SAL03, CEIL(T.SALARY/9+NVL(C.COMM,0)) SAL04,
        CEIL(T.SALARY/18+NVL(C.COMM,0)) SAL05, CEIL(T.SALARY/9+NVL(C.COMM,0)) SAL06,
        CEIL(T.SALARY/18+NVL(C.COMM,0)) SAL07, CEIL(T.SALARY/9+NVL(C.COMM,0)) SAL08,
        CEIL(T.SALARY/18+NVL(C.COMM,0)) SAL09, CEIL(T.SALARY/9+NVL(C.COMM,0)) SAL10,
        CEIL(T.SALARY/18+NVL(C.COMM,0)) SAL11, CEIL(T.SALARY/9+NVL(C.COMM,0)) SAL12
FROM TEMP T, TCOM C
WHERE T.EMP_ID = C.EMP_ID(+) AND C.WORK_YEAR(+) = '2019';
--과장 직급을 가질만한 나이에 포함되는 사람이 누군지 현재 직급에 관계없이 읽어오기(사번,성명,나이,현재직급 만 보여 주세요)
SELECT T.EMP_ID, T.EMP_NAME, 
        (SYSDATE-T.BIRTH_DATE)/365 AGE, 
        T.LEV
FROM TEMP T, EMP_LEVEL L
WHERE T.BIRTH_DATE BETWEEN ADD_MONTHS(SYSDATE,-1*L.TO_AGE*12) 
AND ADD_MONTHS(SYSDATE,-1*L.FROM_AGE*12)
AND L.LEV = '과장';
