CREATE USER user01
IDENTIFIED BY pass01;

GRANT CREATE SESSION, CREATE TABLE, CREATE VIEW
TO user01;

GRANT SELECT
ON DEPARTMENTS
TO user01, SCOTT;

GRANT UPDATE(LOCATION_ID)
ON DEPARTMENTS
TO user01;

--권한에 대한 상속 WITH GRANT OPTION;
GRANT UPDATE
ON HR.DEPARTMENTS
TO PUBLIC;

REVOKE SELECT, UPDATE
ON DEPARTMENTS
FROM USER01;
--ROLE
CREATE ROLE MAN_ROLE;
--ROLE에 권한부여
GRANT CREATE TABLE, CREATE VIEW
TO MAN_ROLE;
--ROLE을 사용자에게 부여
GRANT MAN_ROLE
TO user01, SCOTT;
--부여한 권한 확인
SELECT * FROM ROLE_SYS_PRIVS WHERE ROLE = 'MAN_ROLE';
SELECT * FROM ROLE_TAB_PRIVS;
SELECT * FROM USER_ROLE_PRIVS;
SELECT * FROM USER_TAB_PRIVS_MADE;
SELECT * FROM USER_TAB_PRIVS_RECD;
SELECT * FROM USER_COL_PRIVS_MADE;
SELECT * FROM USER_COL_PRIVS_RECD;
--
SELECT USERENV('SID') FROM DUAL;
--1. SESEION에서 이순신의 취미를 활쏘기로 변경
UPDATE TEMP
SET HOBBY = '말타기'
WHERE EMP_NAME = '이순신';
--LOCK 확인
-- LOCK 획득 확인
SELECT A.SESSION_ID, A.ORACLE_USERNAME,
       A.PROCESS, A.LOCKED_MODE,
       C.LOCK_TYPE, C.MODE_HELD,
       C.MODE_REQUESTED, C.BLOCKING_OTHERS
FROM   V$LOCKED_OBJECT A, DBA_LOCKS C
WHERE  A.SESSION_ID = USERENV('SID')
AND    C.SESSION_ID = A.SESSION_ID
AND    C.LOCK_ID1 = A.OBJECT_ID;

SELECT * FROM TEMP
WHERE EMP_NAME = '이순신';

ROLLBACK;
--1 SESSION
SELECT *
FROM TEMP
WHERE EMP_NAME = '이순신'
FOR UPDATE NOWAIT;

--과제1. UPDATE DML로 TRANSACTION 시작하고 TRANSATION을 종료할 수 있는 방법을 모두 기술하고
-- 각 방법에 대해 트랜잭션 종료 상황을 구현하고 확인 문장 작성
UPDATE TEMP
SET HOBBY = '말타기'
WHERE EMP_NAME = '이순신';
ROLLBACK;
COMMIT;
CREATE TABLE TEMP2(
EMP_NNN VARCHAR(20) NOT NULL PRIMARY KEY
);
ALTER TABLE TEMP
MODIFY (EMP_NAME VARCHAR2(10));
DESC TEMP
SELECT * FROM TEMP2;
SELECT HOBBY FROM TEMP WHERE EMP_NAME ='이순신';
--
UPDATE TEMP
SET HOBBY ='말타기'
WHERE EMP_NAME = '이순신';

DESC TEMP;
--2. SAVEPOINT
--   2.1 STUDY01에서 T1_DATA의 MAX(NO) 확인 
SELECT MAX(NO)
FROM T1_DATA;
--   2.2 확인된 NO보다 1  작은 값을 조건으로 T1_DATA에서 DELETE 수행
DELETE
FROM T1_DATA
WHERE NO = (SELECT MAX(NO)-1
            FROM T1_DATA);
--   2.3 삭제 여부 확인 후 SAVEPOINT T1_1 수행
SELECT *
FROM T1_DATA
WHERE NO = (SELECT MAX(NO)-1
            FROM T1_DATA);
SAVEPOINT T1_1;
--   2.4 2.1에서 확인한 NO 값으로 DELETE 수행
DELETE
FROM T1_DATA
WHERE NO = (SELECT MAX(NO)
            FROM T1_DATA);
--   2.5 삭제여부 확인
SELECT *
FROM T1_DATA
WHERE NO = (SELECT MAX(NO)
            FROM T1_DATA);
--   2.6 T1_1 SAVEPOINT로 ROLLABCK 수행
ROLLBACK TO T1_1;
--   2.7 ROLLBACK TO T1_1;
--   2.8 T1_1 SAVEPOINT 실행 이전 데이터는 아직 삭제 상태고 이후 데이터는 ROLLABACK으로 복구확인
SELECT *
FROM T1_DATA
WHERE NO = (SELECT MAX(NO)
            FROM T1_DATA);
--   2.9 ROLLBACK 수행으로 원상 복구
ROLLBACK;
SELECT *
FROM T1_DATA
WHERE NO = (SELECT MAX(NO)
            FROM T1_DATA);
--3.STUDY01로 로그인해 STUDY03 유저 생성 ? PASSWORD는 ‘PASS01’
CREATE USER STUDY03
IDENTIFIED BY PASS01;
--4. STUDY03의 PASSWORD를 USER명과 동일하게 변경
ALTER USER STUDY03 IDENTIFIED BY STUDY03;
--5. STUDY03에게 세션생성, 테이블생성, 뷰생성 권한을 부여
GRANT CREATE SESSION, CREATE TABLE, CREATE VIEW
TO STUDY03;
--5-1 STUDY03에 CONNECT 후 간단한 테이블과 뷰 생성 확인
CONNECT STUDY03/STUDY03; 
CREATE TABLE T1 (A NUMBER);
CREATE VIEW V1 AS SELECT A FROM T1;
--6. STUDY03에게 T1_DATA INSERT, UPDATE 권한 부여
GRANT INSERT, UPDATE
ON T1_DATA
TO STUDY03;
--7. STUDY03에게 T2_DATA SELECT, UPDATE 권한 부여 (WITH GRANT OPTION 으로);
GRANT SELECT, UPDATE
ON T2_DATA
TO STUDY03
WITH GRANT OPTION;
--8. STUDY03에서 STUDY02에게 T1_DATA 와 T2_DATA의 UPDATE 권한 부여 
GRANT UPDATE
ON T1_DATA
TO STUDY02; --이건 안됌

GRANT UPDATE
ON T2_DATA
TO STUDY02;
--9. PUBLIC에 TEMP SELECT 권한 부여
GRANT SELECT
ON TEMP
TO PUBLIC;

REVOKE SELECT ON TEMP FROM PUBLIC;
SELECT * FROM USER_TAB_PRIVS_MADE WHERE TABLE_NAME = 'TEMP';
SELECT * FROM USER_TAB_PRIVS_MADE WHERE TABLE_NAME = 'TDEPT';

-- 보너스문제
CREATE ROLE AMUNA;
GRANT SELECT ON TEMP TO AMUNA;
GRANT AMUNA TO STUDY03;

--문제
--study01은 인사시스템 user이며, study03은 재무 시스템 user입니다.
--재무 시스템에서 인사 시스템에 직원정보, 부서정보에 대한 조회 권한과 직원정보에 대한 입력권한을 요청합니다.
--하지만 향 후 다른 시스템에서 발생할 수 있는 비슷한 유형의 요청에 대응하기 위해,
--인사시스템 관리자는 인사정보들을 이용할 수 있는 권한을 테이블 별로
--1. 단순 읽기 권한, 2. 변경권한, 3. 입력권한, 4. 삭제권한으로 나누어 관리하고자 합니다.
--이후 시스템별 요청에 따라 적절한 권한을 4가지 권한의 조합으로 부여하고자 합니다.
--(권한 관리는 테이블 레벨에서만 합니다.)
--단, 인사정보에서 부여된 권한을 임으로 부여 받은 시스템이 다른 시스템에 재부여할 수 없게 할 예정이며,
--정의된 role권한을 통하지 않은 유저에 직접적은 grant는 허용하지 않을 예정입니다.
--이에 대한 대응 방안을 수립한 후 재무 시스템에 선 적용하고자 합니다.   
--따라서 인사정보에서 현재 권한이 부여된 상태를 조회할 수 있어야 합니다.
--또한 관련된 권한 부여 정책을 별도의 테이블에 데이터로 관리하여 현재 부여상태와 수시로 비교하고자 합니다.
--관련된 내용의 테이블을 설계해 구현하고, 권한 정책을 입력하며,
--관련된 권한 정책이 실제 적용되고 있는지 확인하는 쿼리를 작성하시오.

SELECT * FROM USER_TABLES;
SELECT * FROM USER_ROLE_PRIVS;
SELECT * FROM USER_USERS;
SELECT * FROM ROLE_SYS_PRIVS
WHERE ROLE = 'ROLE_MAN';