INSERT ALL
    INTO SAL_HISTORY VALUES (EMPID, HIREDATE, SAL)
    INTO MGR_HISTORY VALUES (EMPID, MGR,SAL)
    SELECT EMPLOYEE_ID EMPID, HIRE_DATE HIREDATE,
            SALARY SAL, MANAGER_ID MGR
    FROM EMPLOYEES
    WHERE EMPLOYEE_ID > 200;
-- 
CREATE TABLE MGR_HISTORY
AS
    SELECT EMPLOYEE_ID EMPID, SALARY SAL, MANAGER_ID MGR
    FROM EMPLOYEES
    WHERE EMPLOYEE_ID = -1;
--
CREATE TABLE SAL_HISTORY
AS
    SELECT EMPLOYEE_ID EMPID, HIRE_DATE HIREDATE,
            SALARY SAL
    FROM EMPLOYEES
    WHERE EMPLOYEE_ID = -1;    

SELECT * FROM MGR_HISTORY;
SELECT * FROM SAL_HISTORY;
--CONDITIONAL INSERT ALL
INSERT ALL
    WHEN SAL > 10000 THEN
        INTO SAL_HISTORY VALUES (EMPID, HIREDATE, SAL)
    WHEN MGR > 200 THEN
        INTO MGR_HISTORY VALUES (EMPID, MGR, SAL)
        SELECT EMPLOYEE_ID EMPID, HIRE_DATE HIREDATE,
                SALARY SAL, MANAGER_ID MGR
        FROM EMPLOYEES
        WHERE EMPLOYEE_ID > 200;
SELECT * FROM MGR_HISTORY;
--CONDITIONAL FIRST INSERT
INSERT ALL 
    WHEN SAL > 10000 THEN
        INTO SPECIAL_SAL VALUES (DEPTID, SAL)
    WHEN HIREDATE LIKE('%00%') THEN
        INTO HIREDATE_HISTORY_00 VALUES (DEPTID,HIREDATE)
    WHEN HIREDATE LIKE('%99%') THEN
        INTO HIREDATE_HISTORY_99 VALUES (DEPTID,HIREDATE)
    ELSE
        INTO HIREDATE_HISTORY VALUES (DEPTID,HIREDATE)
         SELECT DEPARTMENT_ID DEPTID, SUM(SALARY) SAL,
                MAX(HIRE_DATE) HIREDATE
        FROM EMPLOYEES
        GROUP BY DEPARTMENT_ID;
--
CREATE TABLE SPECIAL_SAL
AS
    SELECT DEPARTMENT_ID DEPTID, SALARY SAL
    FROM EMPLOYEES
    WHERE EMPLOYEE_ID = -1; 

CREATE TABLE HIREDATE_HISTORY_00
AS
    SELECT DEPARTMENT_ID DEPTID, HIRE_DATE HITEDATE
    FROM EMPLOYEES
    WHERE EMPLOYEE_ID = -1; 

CREATE TABLE HIREDATE_HISTORY_99
AS
    SELECT DEPARTMENT_ID DEPTID, HIRE_DATE HITEDATE
    FROM EMPLOYEES
    WHERE EMPLOYEE_ID = -1; 

CREATE TABLE HIREDATE_HISTORY
AS
    SELECT DEPARTMENT_ID DEPTID, HIRE_DATE HITEDATE
    FROM EMPLOYEES
    WHERE EMPLOYEE_ID = -1; 
--결과   
SELECT * FROM SPECIAL_SAL;
SELECT * FROM HIREDATE_HISTORY_00;
SELECT * FROM HIREDATE_HISTORY_99;
SELECT * FROM HIREDATE_HISTORY;
--PIVOTING INSERT
INSERT ALL
    INTO SALES_INFO VALUES (EMPLOYEE_ID, WEEK_ID, SALES_MON)
    INTO SALES_INFO VALUES (EMPLOYEE_ID, WEEK_ID, SALES_TUE)
    INTO SALES_INFO VALUES (EMPLOYEE_ID, WEEK_ID, SALES_WED)
    INTO SALES_INFO VALUES (EMPLOYEE_ID, WEEK_ID, SALES_THU)
    INTO SALES_INFO VALUES (EMPLOYEE_ID, WEEK_ID, SALES_FRI)
    SELECT EMPLOYEE_ID, WEEK_ID, SALES_MON, SALES_TUE,
            SALES_WED, SALES_THU, SALES_FRI
    FROM SALES_SOURCE_DATA;
--테이블 생성
CREATE TABLE SALES_SOURCE_DATA
AS
SELECT EMPLOYEE_ID,
        NO WEEK_ID,
        CEIL(DBMS_RANDOM.VALUE(1000,5000)) SALES_MON,
        CEIL(DBMS_RANDOM.VALUE(1000,5000)) SALES_TUE,
        CEIL(DBMS_RANDOM.VALUE(1000,5000)) SALES_WED,
        CEIL(DBMS_RANDOM.VALUE(1000,5000)) SALES_THU,
        CEIL(DBMS_RANDOM.VALUE(1000,5000)) SALES_FRI
FROM EMPLOYEES,
    T1_DATA
WHERE NO < 6;
--
CREATE TABLE SALES_INFO
AS
    SELECT EMPLOYEE_ID, WEEK_ID, SALES_MON SALES_DAY
    FROM SALES_SOURCE_DATA
    WHERE EMPLOYEE_ID = -1;
--결과
SELECT * FROM SALES_INFO;
SELECT COUNT(*)*5 FROM SALES_SOURCE_DATA;
--CSV로 저장
SELECT EMPLOYEE_ID EMPNO,
        FIRST_NAME||' '||LAST_NAME
FROM EMPLOYEES;
--외부 테이블 생성
CREATE DIRECTORY EMP_DIR AS 'C:\Users\HeeLee\Desktop';

CREATE TABLE OLDEMP(EMPNO NUMBER,
    EMPNAME CHAR(46) )
    ORGANIZATION EXTERNAL
    (TYPE ORACLE_LOADER
    DEFAULT DIRECTORY EMP_DIR
    ACCESS PARAMETERS
    ( RECORDS DELIMITED BY NEWLINE
        BADFILE 'BAD.EMP'
        LOGFILE 'LOG.EMP'
        FIELDS TERMINATED BY '\t'
        (
        EMPNO CHAR, EMPNAME CHAR
        )
    )
    LOCATION('EMP1.TXT')
)
PARALLEL 4
REJECT LIMIT 300;
DROP DIRECTORY EMP_DIR;
DROP TABLE OLDEMP;
SELECT * FROM OLDEMP;
--테이블 생성시 인덱스 생성
CREATE TABLE NEW_EMP
(EMPLOYEE_ID NUMBER(6)
                PRIMARY KEY USING INDEX
                (CREATE INDEX EMP_ID_IDX ON
                NEW_EMP (EMPLOYEE_ID) ),
FIRST_NAME VARCHAR(20),
LAST_NAME VARCHAR(25));
SELECT * FROM NEW_EMP;
--1. TDEPT의 부서 정보를 CSV(콤마구분자) 로 저장하고
--   외부테이블(OUT_DEPT) 생성
--CSV로 저장
SELECT * FROM TDEPT;
--DIR만들기
CREATE DIRECTORY TDEPT_DIR AS 'C:\Users\HeeLee\Desktop';

CREATE TABLE OLDTDEPT(DEPT_CODE VARCHAR2(20),
    DEPT_NAME VARCHAR2(20),
    PARENT_DEPT VARCHAR2(20),
    USE_YN VARCHAR2(1),
    AREA VARCHAR2(20),
    BOSS_ID VARCHAR(20))
    ORGANIZATION EXTERNAL
    (TYPE ORACLE_LOADER
    DEFAULT DIRECTORY TDEPT_DIR
    ACCESS PARAMETERS
    ( RECORDS DELIMITED BY NEWLINE
        BADFILE 'BAD.TDEPT'
        LOGFILE 'LOG.TDEPT'
        FIELDS TERMINATED BY ','
            (
            DEPT_CODE VARCHAR2,
            DEPT_NAME VARCHAR2,
            PARENT_DEPT VARCHAR2,
            USE_YN VARCHAR2,
            AREA VARCHAR2,
            BOSS_ID VARCHAR2
            )
        )
    LOCATION('TDEPT1.CSV')
)
PARALLEL 4
REJECT LIMIT 300;
DROP DIRECTORY TDEPT_DIR;
DROP TABLE OLDTDEPT;
SELECT * FROM OLDEMP;
SELECT * FROM OLDTDEPT;
SELECT * FROM TDEPT_DIR;
--2.  직원의 소속부서가 변경될 때 마다 현재상태 관리자 정보를 별도로 보관하기 위한 
--     HISTORY 테이블 생성  
--     TMAN_HISTORY(CHANGE_DATE VARCHAR2(08), 
--     EMP_ID NUMBER, 
--     DEPT_CODE VARCHAR(20), BOSS_ID NUMBER, IS_NOW VARCHAR2(01) ); 
CREATE TABLE TMAN_HISTORY(CHANGE_DATE VARCHAR2(08), 
     EMP_ID NUMBER, 
     DEPT_CODE VARCHAR(20), BOSS_ID NUMBER, IS_NOW VARCHAR2(01) ); 
--3.  직원의  연봉 정보가 변경될 때 마다 연봉 변경일자와 변경 전.후 금액을 보관하는 HISTORY
--     테이블 생성  
--     TSAL_HISTORY(CHANGE_DATE VARCHAR2(08), 
--     EMP_ID NUMBER, BEF_SALARY NUMBER, AFT_SALARY NUMBER)
 CREATE TABLE TSAL_HISTORY(CHANGE_DATE VARCHAR2(08), 
     EMP_ID NUMBER, BEF_SALARY NUMBER, AFT_SALARY NUMBER);
--4.  현재 직원정보를 읽어 직급이 사원인 경우 HISTORY 테이블 두 곳에 현재 상태 정보 입력
--     (변경일자:현재일자,  IS_NOW:‘Y’,  BEF_SALARY:0,  AFT_SALARY:현재SALARY)
SELECT * FROM TMAN_HISTORY;
SELECT * FROM TSAL_HISTORY;
INSERT ALL
    INTO TMAN_HISTORY VALUES(CHANGE_DATE, EMP_ID, DEPT_CODE, BOSS_ID, IS_NOW)
    INTO TSAL_HISTORY VALUES(CHANGE_DATE, EMP_ID, BEF_SALARY, AFT_SALARY)
SELECT TO_CHAR(SYSDATE,'YYYYMMDD') CHANGE_DATE, A.EMP_ID EMP_ID, A.DEPT_CODE DEPT_CODE, B.BOSS_ID BOSS_ID, 
        'Y' IS_NOW, 0 BEF_SALARY, A.SALARY AFT_SALARY
FROM TEMP A, TDEPT B
WHERE A.DEPT_CODE = B.DEPT_CODE
AND A.LEV = '사원';
--5.  현재 직원정보를 읽어 직급이 대리인 경우 HISTORY 테이블 두 곳에 현재 상태 정보 입력하되
--    TMAN_HISTORY에는 AA0001 부서만을 대상으로 TSAL_HISTORY에는 
--    SALARY가 5천만원 이상인 경우만을 대상으로 동시 인서트 수행
INSERT ALL
    WHEN DEPT_CODE = 'AA0001' THEN
    INTO TMAN_HISTORY VALUES(CHANGE_DATE, EMP_ID, DEPT_CODE, BOSS_ID, IS_NOW)
     WHEN AFT_SALARY >= 50000000 THEN
    INTO TSAL_HISTORY VALUES(CHANGE_DATE, EMP_ID, BEF_SALARY, AFT_SALARY)
SELECT TO_CHAR(SYSDATE,'YYYYMMDD') CHANGE_DATE, A.EMP_ID EMP_ID, A.DEPT_CODE DEPT_CODE, B.BOSS_ID BOSS_ID, 
        'Y' IS_NOW, 0 BEF_SALARY, A.SALARY AFT_SALARY
FROM TEMP A, TDEPT B
WHERE A.DEPT_CODE = B.DEPT_CODE
AND A.LEV = '대리';
--6. 현재 직원정보를 읽어 직급이 과장인 경우 HISTORY 테이블 두 곳에 현재 상태 정보를 입력하되
--    TMAN_HISTORY에는 AA0001 부서만을 대상으로 
--    TSAL_HISTORY에는 SALARY가 5천만원 이상인 경우만을 대상으로 동시 인서트 수행 
--    (단, 첫 번째  TMAN에 입력된 경우 TSAL 입력 안함)
INSERT FIRST
    WHEN DEPT_CODE = 'AA0001' THEN
    INTO TMAN_HISTORY VALUES(CHANGE_DATE, EMP_ID, DEPT_CODE, BOSS_ID, IS_NOW)
     WHEN AFT_SALARY >= 50000000 THEN
    INTO TSAL_HISTORY VALUES(CHANGE_DATE, EMP_ID, BEF_SALARY, AFT_SALARY)
SELECT TO_CHAR(SYSDATE,'YYYYMMDD') CHANGE_DATE, A.EMP_ID EMP_ID, A.DEPT_CODE DEPT_CODE, B.BOSS_ID BOSS_ID, 
        'Y' IS_NOW, 0 BEF_SALARY, A.SALARY AFT_SALARY
FROM TEMP A, TDEPT B
WHERE A.DEPT_CODE = B.DEPT_CODE
AND A.LEV = '과장';

--7. T2_DATA를 ROW형식으로 관리하기 위한 테이블 생성 YM = 2019 01~12월
--    T2_TRAN (EMP_ID NUMBER, YM VARCHAR2(06), MSAL NUMBER)
CREATE TABLE T2_TRAN(
        EMP_ID NUMBER,
        YM VARCHAR2(06),
        MSAL NUMBER
);
--8. T2_DATA를 INSERT ALL 문장이용 T2_TRAN 으로 INSERT
INSERT ALL 
    INTO T2_TRAN VALUES(EMP_ID,201901,SAL01)
    INTO T2_TRAN VALUES(EMP_ID,201902,SAL02)
    INTO T2_TRAN VALUES(EMP_ID,201903,SAL03)
    INTO T2_TRAN VALUES(EMP_ID,201904,SAL04)
    INTO T2_TRAN VALUES(EMP_ID,201905,SAL05)
    INTO T2_TRAN VALUES(EMP_ID,201906,SAL06)
    INTO T2_TRAN VALUES(EMP_ID,201907,SAL07)
    INTO T2_TRAN VALUES(EMP_ID,201908,SAL08)
    INTO T2_TRAN VALUES(EMP_ID,201909,SAL09)
    INTO T2_TRAN VALUES(EMP_ID,201910,SAL10)
    INTO T2_TRAN VALUES(EMP_ID,201911,SAL11)
    INTO T2_TRAN VALUES(EMP_ID,201912,SAL12)
SELECT *
FROM T2_DATA;
--연습문제
CREATE TABLE TEST34(
KEY1 VARCHAR2(03),
KEY_TYPE VARCHAR2(01),
AMT NUMBER,
CONSTRAINT TEST34_PK PRIMARY KEY (KEY1)
);
INSERT INTO TEST34 VALUES('A01', '1',10);
INSERT INTO TEST34 VALUES('A02', '2',20);
INSERT INTO TEST34 VALUES('A03', '1',30);
INSERT INTO TEST34 VALUES('A04', '2',40);
INSERT INTO TEST34 VALUES('A05', '3',50);
INSERT INTO TEST34 VALUES('A06', '3',60);
INSERT INTO TEST34 VALUES('A07', '1',70);
INSERT INTO TEST34 VALUES('A08', '2',80);
INSERT INTO TEST34 VALUES('A09', '1',90);
commit;
--KEY 1+2 , 1+3 구하기 340 310
--1.집합연산자
SELECT * FROM TEST34
ORDER BY 2;
SELECT SUM(AMT)
FROM TEST34
WHERE KEY_TYPE = 1
OR KEY_TYPE = 2
UNION ALL
SELECT SUM(AMT)
FROM TEST34
WHERE KEY_TYPE = 1
OR KEY_TYPE = 3;
--2.조인
SELECT SUM(DISTINCT A.AMT), SUM(DISTINCT B.AMT)
FROM TEST34 A, TEST34 B
WHERE A.KEY_TYPE = B.KEY_TYPE
AND A.KEY_TYPE = 1 OR A.KEY_TYPE = 2
AND B.KEY_TYPE = 1 OR B.KEY_TYPE = 3
AND A.KEY_TYPE <> 3;
SELECT SUM(AMT) FROM TEST34;
--
SELECT DECODE(NO,1,'A','B'), SUM(AMT)
FROM TEST34, T1_DATA
WHERE (NO = 1 AND KEY_TYPE IN (1,2)) OR (NO = 2 AND KEY_TYPE IN (1,3))
GROUP BY DECODE(NO,1,'A','B');
--3.ANALYTIC FUNTION (WINDOW FUNCTION)
SELECT SUM(AMT),
        SUM(AMT) + LAG(KEY_TYPE,1) OVER(PARTITION BY KEY_TYPE,SUM(AMT) ORDER BY KEY_TYPE),
        SUM(AMT) + LAG(KEY_TYPE,2) OVER(PARTITION BY KEY_TYPE,SUM(AMT) ORDER BY KEY_TYPE)
FROM TEST34
GROUP BY KEY_TYPE;
