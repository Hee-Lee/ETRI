CREATE SEQUENCE DEPT_DEPTNO
        INCREMENT BY 1
        START WITH 91
        MAXVALUE 99
        NOCACHE
        NOCYCLE;

SELECT * FROM USER_SEQUENCES;
DROP SEQUENCE DEPT_DEPTNO;
--SCOTT-------------------------------------------
CREATE SEQUENCE DEPT_DEPTNO
        INCREMENT BY 1
        START WITH 91
        MAXVALUE 99
        CACHE 3
        NOCYCLE;

SELECT * FROM USER_SEQUENCES;
DROP SEQUENCE DEPT_DEPTNO;
--
INSERT INTO DEPT
VALUES (DEPT_DEPTNO.NEXTVAL, '영업부', '분당구 정자동');

SELECT DEPT_DEPTNO.CURRVAL
FROM DUAL;
--사용자 인덱스 생성
CREATE INDEX EMP_ENAME_IDX
ON EMP(ENAME);
--인덱스생성확인
SELECT C.INDEX_NAME, C.COLUMN_NAME, C.COLUMN_POSITION, I.UNIQUENESS
FROM USER_INDEXES I, USER_IND_COLUMNS C
WHERE C.INDEX_NAME = I.INDEX_NAME
AND C.TABLE_NAME = 'EMP';
--함수기반 인덱스
CREATE INDEX UPPER_EMP_ENAME_IDX
ON EMP(UPPER(ENAME));
--인덱스 삭제
DROP INDEX UPPER_EMP_ENAME_IDX;
--시노님 생성
CREATE SYNONYM GUBUN
FOR SALGRADE;
----------------------------------------------------------------------------------
CREATE SYNONYM GUBUN
FOR TEMP;
--시노님 확인
SELECT * FROM GUBUN;
--시노님 삭제
DROP SYNONYM GUBUN;
--1. EXT_NO 라는 시퀀스를 생성하되 1에서 시작해 증분은 1씩 최대 1000까지 증가하다 
--  다시 1로 순환 채번 되도록 생성하며 메모리에 CACHE 하지 않습니다.
CREATE SEQUENCE EXT_NO
        INCREMENT BY 1
        START WITH 1
        MAXVALUE 1000
        NOCACHE
        CYCLE;
SELECT EXT_NO.NEXTVAL FROM DUAL;
SELECT EXT_NO.CURRVAL FROM DUAL;
--2. SEQUENCE 생성 여부 DICTIONARY VIEW를 통해 확인
SELECT * 
FROM USER_SEQUENCES
WHERE SEQUENCE_NAME = 'EXT_NO';
--3. EXIT_NO 의 현재 SEQUENCE 값 확인 => 오류 확인
SELECT EXT_NO.CURRVAL FROM DUAL;
--4. EXT_NO 의 새로운 번호 채번
SELECT EXT_NO.NEXTVAL FROM DUAL;
--5. 3번 재실행으로 현재까지 채번 번호 확인
SELECT EXT_NO.CURRVAL FROM DUAL;
--6.세션과 USER간 동일 시퀀스를 이용한 채번을 통해 채번 규칙 확인
--(CURRVAL, NEXTVAL의 작동 방식이 상식적으로 ACCEPTABLE 한지)
--7. T1_DATA에 PROD_AM NUMBER 컬럼을 ADD
ALTER TABLE T1_DATA
ADD PROD_AM NUMBER;
SELECT * FROM T1_DATA;
--8. T1_DATA의 NO가 10보다 작은 값을 대상으로 PROD_AM 값을
--EXT_NO 시퀀스에서 읽어 연속으로 1씩 증분하는 값으로 업데이트
--(예: NO 값이 1인 PROD_AM이 2라면 NO 값이 2인 PROD_AM 값은
--3이 되는 식으로 9건의 PROD값이 계속 1씩 증가해야 함)
UPDATE T1_DATA 
SET PROD_AM = EXT_NO.NEXTVAL
WHERE NO < 10;
SELECT * FROM T1_DATA;
--9. TEMP를 이용 SELECT 절에 EXT_NO의 NEXTVAL만을 SELECT하여 CREATE TABLE TSEQ1 생성
CREATE TABLE TSEQ1 AS SELECT EXT_NO.NEXTVAL FROM TEMP;
--10. ALTER 명령을 이용 EXT_NO를 CACHE 10으로 변경 후 DICTIONARY VIEW 확인
ALTER SEQUENCE EXT_NO
CACHE 10;
--11. EXT_NO에서 체번해 TSEQ1에 1건 INSERT하기
INSERT INTO TSEQ1
SELECT EXT_NO.CURRVAL FROM DUAL;
--보너스문제
INSERT INTO T1_DATA(NO)
SELECT A.NO + 10000*B.NO
FROM T1_DATA A, T1_DATA B
WHERE B.NO < 21;

SELECT COUNT(*) FROM T1_DATA;
--
EXPLAIN PLAN FOR
SELECT *
FROM T1_DATA
WHERE NO < 150000;
--과제
--1. USER_INDEXES 와 USER_IND_COLUMNS 를 이용 INDEX 를 조회하고 
--   어떤 인덱스가 PRIMARY KEY 와 UNIQUE INDEX 이고 어느 것이 일반 인덱스 인지 구별 
SELECT * FROM USER_INDEXES;
SELECT * FROM USER_IND_COLUMNS;
SELECT A.INDEX_NAME, B.CONSTRAINT_TYPE, A.UNIQUENESS
FROM USER_INDEXES A, USER_CONSTRAINTS B
WHERE A.INDEX_NAME = B.INDEX_NAME(+);

CREATE UNIQUE INDEX UK_EMP_NAME ON TEMP(EMP_NAME);
--2. SALARY의 천만 단위가 같으면 같은 값으로 간주하여 직급, 천만단위급여, 
--   이름 순으로 정렬을 하되, INDEX를 이용한 정렬을 하고 싶은 경우 인덱스 생성
SELECT LEV, SALARY, EMP_NAME
FROM TEMP
WHERE SALARY IN(SELECT (FLOOR(SALARY/POWER(10,7))*POWER(10,7))
                FROM TEMP)
ORDER BY SALARY DESC;
--인덱스를 이용
CREATE INDEX TEMP_SAL_IDX
ON TEMP (FLOOR(SALARY/POWER(10,7)));
--옵티마이저에 설명
EXPLAIN PLAN FOR
--인덱스스캔
SELECT /*+INDEX(TEMP, TEMP_SAL_IDX)*/EMP_NAME, SALARY, (FLOOR(SALARY/POWER(10,7)))
FROM TEMP
WHERE SALARY > 0;

SELECT PLAN_TABLE_OUTPUT FROM TABLE (DBMS_XPLAN.DISPLAY());
--3. T1_DATA의 NO, PROD_AM 컬럼에 T1_INX1 이름으로 복합인덱스 생성 (DICTIONARY VIEW 에서 개별 확인)
CREATE INDEX T1_INX1
ON T1_DATA (NO, PROD_AM);
--확인
SELECT A.INDEX_NAME, A.TABLE_NAME, B.COLUMN_NAME
FROM USER_INDEXES A, USER_IND_COLUMNS B
WHERE A.INDEX_NAME = B.INDEX_NAME
AND A.INDEX_NAME = 'T1_INX1';
--4. STUDY02에서 STUDY01의 TEMP 에 대한 PUBLIC SYNONYM 을 TEMP 라는 이름으로 생성
CREATE PUBLIC SYNONYM TEMP
FOR STUDY01.TEMP;
--5. STUDY02에서 STUDY01의 TDEPT 에 대한 일반 SYNONYM 을 TDEPT 라는 이름으로 생성
CREATE SYNONYM TDEPT
FOR STUDY01.TDEPT;
--6. STUDY03에서 SCHEMA 지정 없이 TEMP와 TDEPT에서 각각 SELECT 결과 확인
SELECT * FROM TEMP;
SELECT * FROM TDEPT;
--7. STUDY03에서 TDEPT의 자료를 SELECT 하여 동일 이름으로 TABLE을 
--   만들되 AREA가 인천인 경우만 입력되도록 CREATE TABLE 문 작성
--=> 시노님 경합
CREATE TABLE TDEPT
AS
SELECT *
FROM TDEPT
WHERE AREA = '인천';
--8. TDEPT 에서 모든 자료를 검색해 어느 유저의 테이블인지 확인
SELECT * FROM ALL_SYNONYMS
WHERE TABLE_NAME = 'TDEPT';
--9. STUDY03에서 TDEPT에 대한 PUBLIC SYNONYM을 TDEPT라고 생성
CREATE PUBLIC SYNONYM TDEPT
FOR STUDY01.TDEPT;
--10. SYNONYM의 운선 순위 스스로 확인
--   1) STUDY02에서 STUDY01.TDEPT를 대상으로 SYNONYM 생성
CREATE SYNONYM TDEPT
FOR STUDY01.TDEPT;
--   2) STUDY03에서 STUDY03.TDEPT 대상으로 PUBLIC SYNONYM 생성
CREATE PUBLIC SYNONYM TDEPT2
FOR TDEPT;
--   3) 일반 시노님과 PUBLIC 시노님의 경합 : 
--      STUDY02에서 TDEPT SELECT
SELECT * FROM TDEPT;
--  4) 테이블과 시노님의 경합
--      STUDY01에서 TDEPT SELECT
SELECT * FROM TDEPT;
--11. STUDY02에서 TDEPT SYNONYM 제거 
DROP SYNONYM TDEPT;
--12. STUDY02에서 TDEPT SELECT 후 STUDY02의 시노님이 제거된 효과 확인
DROP SYNONYM TDEPT;
SELECT * FROM TDEPT;
------------------------------------------------------------------
