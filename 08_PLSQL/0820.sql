--TYPE을 오브젝트로 CREATE
CREATE OR REPLACE TYPE R_TY AS OBJECT(ITEM VARCHAR2(08), QTY NUMBER);
SELECT * FROM USER_OBJECTS
WHERE OBJECT_TYPE = 'TYPE';
SELECT * FROM USER_TYPES;
SELECT * FROM USER_TYPE_ATTRS;
--테이블
CREATE OR REPLACE TYPE T_TY AS TABLE OF R_TY;
--함수
CREATE OR REPLACE FUNCTION F_NT(pIDATE VARCHAR2, pLINE VARCHAR2) RETURN T_TY IS
    vTAB T_TY := T_TY();
    i INTEGER := 0;
    vITEM VARCHAR2(20);
    vQTY NUMBER;
    CURSOR C1 IS
    SELECT ITEM_CODE ITEM, SUM(ITEM_QTY) QTY
    FROM JIT_DELIVERY_PLAN
    WHERE DELIVERY_DATE = pIDATE
    AND LINE_NO = pLINE
    GROUP BY ITEM_CODE;
BEGIN
    OPEN C1;
    LOOP
        FETCH C1 INTO vITEM, vQTY;
        EXIT WHEN C1%NOTFOUND;
        i := i + 1;
        vTAB.EXTEND;
        vTAB(i) := R_TY(vITEM, vQTY); -- 중첩테이블에 데이터 입력
    END LOOP;
    CLOSE C1;
    RETURN vTAB;
END;
--함수로 SELECT
SELECT * 
FROM TABLE(F_NT('20191001', 'L01'));

--특정 사원 번호를 매개변수로 넘기면 해당 사원을 기준으로 상향 검색을 수행하고
--검색 결과의 INDENTATION, EMP_ID, EMP_NAME을
--중첩테이블에 보관해 결과로 RETURN 해주는 함수를
--구현하고 결과를 SELECT 해 보여주세요.
CREATE OR REPLACE TYPE B_TY AS OBJECT(B_UP VARCHAR2(50), p_ID NUMBER, p_NAME VARCHAR2(20));
CREATE OR REPLACE TYPE E_TY AS TABLE OF B_TY;
CREATE OR REPLACE FUNCTION F_BOTTOM_UP(pID NUMBER) RETURN E_TY IS
    vTAB E_TY := E_TY();
    CNT NUMBER := 0;
    vUP VARCHAR2(20);
    vID NUMBER;
    vNAME VARCHAR2(20);
    CURSOR CUR IS
    SELECT LPAD(' ', LENGTH(EMP_NAME) + (LEVEL*3) - 2, '-') INDENTATION, EMP_ID,
       EMP_NAME
    FROM VEMP_BOSS
    START WITH EMP_ID = pID
    CONNECT BY PRIOR BOSS_ID = EMP_ID;
BEGIN
    OPEN CUR;
    LOOP
        FETCH CUR INTO vUP, vID, vNAME;
        EXIT WHEN CUR%NOTFOUND;
        CNT := CNT + 1;
        vTAB.EXTEND;
        vTAB(CNT) := B_TY(vUP, vID, vNAME);
    END LOOP;
    CLOSE CUR;
    RETURN vTAB;
END;
SELECT * 
FROM TABLE(F_BOTTOM_UP('20190303'));

--
DECLARE
    TYPE T1 IS VARRaY(10) OF INTEGER;
    VA T1 := T1(2,3,5);
    
    TYPE NT1 IS VARRaY(10) OF T1;
    NVA NT1 := NT1(VA, T1(55,6,73), T1(2,4), VA);
    
    i INTEGER;
    VA1 T1;
BEGIN
    i := NVA(2)(3);
    DBMS_OUTPUT.PUT_LINE('i=' || I);
    NVA.EXTEND; --첨가자 개수를 넘었기 때문
    nva(5) := T1(56,32);
    NVA(4) := T1(45,44,43,42,41,40);
    DBMS_OUTPUT.PUT_LINE('4,4:'||NVA(4)(4));
    NVA(4)(4) := 500;
    DBMS_OUTPUT.PUT_LINE('4,4:'||NVA(4)(4));
END;
/*과제1.
 VARRAY에 JIT_DELIVERY_PLAN 에서 읽은 ITEM 별 날짜별 수량 정보를 모두 저장하고
 10월 3일의 ITEM 05번의 수량과
 10월 5일의 ITEM 10번의 수량을 출력합니다.*/
SELECT * FROM JIT_DELIVERY_PLAN;
DECLARE
    C1 NUMBER;
    C2 NUMBER;
    C3 NUMBER;
    TYPE T1 IS VARRaY(10) OF INTEGER;
    VA T1 := T1(0,0,0,0,0,0,0,0,0,0);
    
    TYPE T2 IS VARRaY(10) OF T1;
    NVA T2 := T2(VA,VA,VA,VA,VA,VA,VA,VA,VA,VA);
    I INTEGER;
    
    CURSOR CUR1 IS
    SELECT SUBSTR(DELIVERY_DATE,7,2) R1,
            SUBSTR(ITEM_CODE,2,2) C1,
            SUM(ITEM_QTY)
    FROM JIT_DELIVERY_PLAN
    WHERE DELIVERY_DATE BETWEEN '20191001' AND '20191005'
    GROUP BY SUBSTR(DELIVERY_DATE,7,2),
                SUBSTR(ITEM_CODE,2,2)
    ORDER BY 1,2;
BEGIN
    OPEN CUR1;
    LOOP
        FETCH CUR1 INTO C1, C2, C3;   
        EXIT WHEN CUR1%NOTFOUND;
        NVA(C1)(C2) := C3;
    END LOOP;
    CLOSE CUR1;
    DBMS_OUTPUT.PUT_LINE('3일 5번 아이템: '||NVA(3)(5));
    DBMS_OUTPUT.PUT_LINE('5일 10번 아이템: '||NVA(5)(10));
END;
/*과제2.
 1에서부터 10까지의 2차원 VARRAY 100 CELL에 각각의 행의열 제곱 값을 저장하고
 5의5제곱과 7의3제곱을 출력합니다.*/
DECLARE
    TYPE T1 IS VARRAY(10) OF INTEGER;
    VA1 T1 := T1(0,0,0,0,0,0,0,0,0,0);
    TYPE T2 IS VARRAY(10) OF T1;
    VA2 T2 := T2(VA1,VA1,VA1,VA1,VA1,VA1,VA1,VA1,VA1,VA1);
BEGIN
    FOR I IN 1..10 LOOP
        FOR J IN 1..10 LOOP
    VA2(I)(J) := POWER(I,J);
        END LOOP;
    END LOOP;
    DBMS_OUTPUT.PUT_LINE(VA2(5)(5));
    DBMS_OUTPUT.PUT_LINE(VA2(7)(2));
END;

/*과제3.
TEMP2를 TEMP1과 비교하여 SALARY가 차이나면 TEMP1의 해당 
EMP_ID의 모든 컬럼을 TEMP2를 기준으로 UPDATE하는 익명블록 작성*/   
CREATE UNIQUE INDEX TEMP2_UK ON TEMP2 (EMP_ID);
DROP TABLE TEMP1;
CREATE TABLE TEMP1 AS SELECT * FROM TEMP;
UPDATE TEMP1
SET SALARY = SALARY * 1.1
WHERE DEPT_CODE LIKE 'A%';
--
SELECT * FROM TEMP1;
SELECT * FROM TEMP2;

DECLARE
    SAL1 NUMBER;
    SAL2 NUMBER;
    EMPID NUMBER;
    
    CURSOR CUR IS
    SELECT A.EMP_ID, A.SALARY A_SAL, B.SALARY B_SAL
    FROM TEMP1 A, TEMP2 B
    WHERE A.EMP_ID = B.EMP_ID;
BEGIN
    OPEN CUR;
    LOOP
    EXIT WHEN CUR%NOTFOUND;
        FETCH CUR INTO EMPID, SAL1, SAL2;
        IF SAL1<>SAL2 THEN
            UPDATE TEMP1 A
            SET (A.EMP_ID, A.EMP_NAME,
                A.BIRTH_DATE, A.DEPT_CODE,
                A.EMP_TYPE, A.USE_YN,
                A.TEL, A.HOBBY,
                A.SALARY, A.LEV, A.EVAL_YN) = (SELECT B.*
                                                FROM TEMP2 B
                                                WHERE A.EMP_ID = B.EMP_ID);
        END IF;
    END LOOP;
    CLOSE CUR;
END;
--1.P_TEMP_BY_PARAM PROCEDURE는 직원이름을 PARAMETER로 받아 TEMP에서 해당직원의 모든 정보를
--  변수에 담아 해당 변수를 PROCEDURE P_TEMP2_CHANGE에 주고 호출
CREATE OR REPLACE PROCEDURE P_TEMP_BY_PARAM(P1 TEMP.EMP_NAME%TYPE) IS
    ITEMP TEMP%ROWTYPE;
BEGIN 
    SELECT *
    INTO ITEMP
    FROM TEMP1
    WHERE EMP_NAME = P1;
    
    P_TEMP2_CHANGE(ITEMP);
END;
--2.P_TEMP2_CHANGE는 1번에서 준 조합 변수를 PARAMETER로 받아
--  TEMP2의 해당건을 변수에 담긴 내용 그대로 UPDATE 후 없으면 INSERT
--(UPDATE 시 SET ROW 이용)
CREATE OR REPLACE PROCEDURE P_TEMP2_CHANGE(P2 TEMP%ROWTYPE) IS 
BEGIN
    UPDATE TEMP2
    SET ROW = P2
    WHERE EMP_ID = P2.EMP_ID;
    
    IF SQL%NOTFOUND THEN
    INSERT INTO TEMP2
    VALUES P2;
    DBMS_OUTPUT.PUT_LINE('얜 INSERT!!!');
    END IF;
END;

EXECUTE P_TEMP_BY_PARAM('이태백');
SELECT * FROM TEMP1;